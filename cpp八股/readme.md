## C++基础
### 1. const
常量指针（底层const）：强调的是所指向对象的不可改变性
指针常量（顶层const）：强调的是指针的不可改变性


### 2. static
    用于控制变量和函数的生命周期、作用域、访问权限，分为：
    静态变量（函数内部使用static修饰的变量）
    静态函数
    静态成员变量
    静态成员函数
    静态局部变量

### 3. define和typedef的区别
    define：
        只是简单的字符串替换
        是在编译的预处理阶段起作用
        可以用来防止头文件重复引用
        不分配内存，给出的是立即数，有多少次使用就进行多少次替换
    typedef：
        在编译、运行的时候起作用。
        在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝
### 4. define和inline的区别
    define：
        定义预处理阶段的宏，知识简单的字符串替换，无类型检查，不安全
    **inline：**
        inline是将内联函数编译完成了函数体直接插入被调用的地方，减少了压栈、跳转和返回的操作。没有普通函数调用时的额外开销。
        内联函数是一种特殊的函数，会进行类型检查；
        对编译器的一种请求，编译器可能拒绝这种请求

### 5. inline
C++中inline编译限制(4):
    1. 不能存在任何形式的循环语句
    2. 不能存在过多的条件判断语句
    3. 函数体不能过于庞大
    4. 内联函数声明必须在调用语句之前

    虚函数无法内联


### 6. const与define的区别
const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。当它们都用于常量定义时，它们的区别有：
    1. 生效时间不一样，const生效于编译阶段，define生效与预处理阶段
    2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的，define定义的常量，运行是直接操作的操作数，并不会放在内存中
    3. const定义的常量是带类型的；define定义常量不带类型，因此define定义的常量不利于类型检查



### 7. 编译器的优化级别有哪些？分别有什么特点？
有7中编译优化级别
-O0/-O1/-O2/-O3   -Os/-Ofast/-Og


### 8. new与malloc的区别
最少有8点不同：
    1. 关键字                        标准函数
    2. 分配内存调用构造函数             分配内存
    3. 类型安全返回对象类型指针          void* + 强转
    4. 分配失败抛出异常                 返回为NULL
    5. 内存大小自动计算                 传入大小
    6. 重载支持                       不支持重载
    7. 按类型对齐                      依赖实现
    8. 内存释放使用delete调用析构函数       使用free，不调用析构函数
    9. 内存分配区域自由存储区               堆区    

### 9. constexpr 和 const
const表示只读的语义，constexpr表示“常量”的语义
一个成员函数或变量，标记为constexpr之后也顺便标记为了const，但是相反并不成立，一个const的变量或函数并不是constexpr的




### 10. volatile关键字
定义：【与const绝对对立，是类型修饰符】，影响编译器编译的结果。
用该关键字声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不需要进行编译优化；会从内存中重新装载内容，而不是直接从寄存器拷贝内容

作用：
指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值，保证对特殊地址的稳定访问。


### 11. extern
声明外部变量【在函数或者文件外部定义的全局变量】

### 12. static

作用：实现多个对象的数据共享 + 隐藏


### 13. 前置++和后置++
细节：
1. 为了区分前后置，重载函数是以参数类型来区分，在调用的时候，编译器默默给int指定为一个0
2. 前置返回引用，后置对象
3. 后置++操作函数需要加上const
4. 处理用户的自定义类型最好使用前置++，因为这样不会创建临时对象，进而


### 14. atomic

atomic<int> value1 = 100;   // 在Linux环境下会报错，，因为这行代码调用的是std::atomic的拷贝函数，而根据C++11语言规范，std::atomic的拷贝构造函数是使用=delete标记禁止编译器自动生成



### 15. 函数指针，如何定义函数指针以及它的使用场景？
函数指针是指向函数的指针变量。它可以用于存储函数的地址，允许在运行时动态选择要调用的函数
使用场景：
    1. 回调函数：
    2. 函数指针数组：使用函数指针数组实现类似于状态机的逻辑，根据不同的输入值调用不同的函数
    3. 动态加载库： 可用于运行时动态加载库中的函数，实现动态链接库的调用
    4. 多态实现： 虚函数和函数指针结合使用可以实现类似于多态的效果
    5. 函数指针作为参数
    6. 实现函数映射表




### 16. 函数指针与指针函数的区别
函数指针是指向函数的指针变量，可以存储特定函数的地址，并在运行时动态选择要调用的函数。
指针函数时一个返回类型为指针的函数，用于返回指向某种类型的数据的指针



### 17. struct和class的区别
struct用于表示一组相关的数据，而class用于表示一个封装了数据和操作的对象
最重要区别在于访问权限和继承权限，struct中默认时public的，而class中是private的




### 18. 静态局部变量/全局变量/局部变量的区别和使用场景
1. 静态局部变量
作用域：限定在定义它的函数内



2. 全局变量


3. 局部变量



### 19. C++强制类型转换
共有四种关键字：
static_cast、dynamic_cast、reinterpret_cast、const_cast
1. static_cast
没有运行时类型检查来保证转换的安全性，所以：
进行上行转换时是安全的，进行下行转换时，是不安全的


2. dynamic_cast(转换信息在虚函数中)
在进行下行转换时，dynamic_cast具有类型检查(信息在虚函数中)，比static_cast更安全
转换后必须是类的指针、引用或者void*，基类还要有虚函数，可以交叉转换


3. reinterpret_cast
可以将整型转换为指针，也可以把指针转换为数组；可以在指针和引用里进行肆意的转换，平台移植性比较差

2. const_cast








## C++内存管理
### 1. 堆和栈的区别
1. 堆和栈都是用于存储程序数据的内存区域。
    栈是一种有限的内存区域，用于存储局部变量、函数调用信息等。

    堆是一种动态分配的内存区域，用于存储程序运行时动态分配的数据。

2. 栈上的变量生命周期与其所在函数的执行周期相同，而堆上的变量生命周期由程序员显示控制，可以使用new和delete、或者malloc和free

3. 栈上的内存分配和释放是自动的，速度较快。而堆上的内存分配和释放需要手动操作，速度相对较慢


### 2. C++内存分区
C++程序运行时，内存被分为几个不同的区域，每个区域负责不同的任务
从低地址------------------》高地址，内存的分配：
  代码区、常量区、全局/静态区、堆区、栈区
其中堆区是从低地址往高地址增长，而栈是从高地址往低地址增长

代码区：        .text
常量区：        .rodata
全局/静态区：    .data(已经初始化)和.bass(未初始化)
堆区：          heap
栈区：           stack

全局/静态区：
    存储全局变量和静态变量。声明周期时整个程序运行期间。在程序启动时分配，程序结束时释放。

常量区也被称为只读区。存储常量数据，如字符串常量。


### 3. 内存泄漏是什么？如何避免？
可以使用valgrind、mtrace进行内存泄漏检查
内存泄漏的类型:
    堆内存泄漏、系统资源泄漏、没有将基类的析构函数定义为virtual造成子类的资源没有正确释放



防止内存泄漏的方法：
    1. 将内存的分配封装在类中，构造函数分配内存，析构函数释放内存
    2. 智能指针

### 4. 构造函数、析构函数都需要声明为虚函数吗？为什么
析构函数：
    需要，当派生类对象中有内存需要回收时，如果析构函数不是虚函数，不会出发动态绑定，只会调用基类析构函数
构造函数：
    不需要，没有意义。虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象确切类型。
    而要创建一个对象，需要知道对象的完整信息。特别是，需要知道创建的确切类型。因此，虚构函数不应该定义为虚函数


### 4. 什么是智能指针？有哪些种类？
智能指针用于管理动态内存对象，其主要目的是内存泄漏和方便资源管理
1. 独占智能指针
unique_ptr<int> 提供堆动态分配的单一对象所有权的独占管理。通过独占所有权，确保只有一个unique_ptr可以拥有指定的内存资源。
注意：
    移动语义和右值引用允许unique_ptr所有权转移时高效地进行转移


### 5. 内存对齐是什么？为什么要考虑内存对齐？
内存对齐是指数据在内存中的存储起始位置为某个值的背书





2. 共享智能指针


3. 弱引用智能指针

















## C++面向对象






## C++STL


## C++泛型编程





C++语法、计算机系统(计算机网络、数据库、操作系统)、简历项目八股


